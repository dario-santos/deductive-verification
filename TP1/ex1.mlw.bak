(* 
primo(n) :
  para i=2 até n-1 fazer
    se i divide n então devolver falso 
  
  devolver verdade
*)

(* 
  Este exercício apresentou-nos diversas dificuldades devido à pouca experiência que possuimos em Why3.
  Na definição das pós condições inicialmente possuiamos demasiadas redundâncias, uma pós condição para cada caso (quando o número é primo, e quando não o é)
   por exemplo possuiamos o exist para quando não fosse primo (existe um número que divide) e o forall para quando era primo (para cada número nenhum divide).
   
  Numa tentativa de simplificar esta complexidade, foi utilizado o módulo Prime do Why3 (prime n). Por não conseguirmos chegar a um invariante para esta 
  póscondição retornamos um paço a trás e recolocamos o (forall i. 2 <= i < n -> (mod n i) = 0)).
*)


(* 
  Otimização: verificar os números até a raíz quadrada de n em vez de até n.
*)



use ref.Ref
use int.Int
use int.EuclideanDivision

let primo (n:int) : bool
  requires{n > 0}
  ensures {result = (forall i. 2 <= i < n -> (mod n i) = 0)}
=
  let resultado = ref true in

  for i=2 to n-1 do
    invariant{2 <= i /\ i <= n }
    invariant{!resultado = (forall j. 2 <= j < i -> (mod n j) = 0)}

    if (mod n i) <> 0 then resultado := false

  done;
  !resultado
