(* 
  k := 1;
  s := b[0];
  c := b[0];
  
  do k <> n 
    c:= min (c+b[k]) b[k];
    s:= min c s;
    
    k:= k+l
  od

*)


(* 
  Referencias:
   - [1] “A note on a standard strategy for developing loop invariants and 
       loops, Sci. Comput. Programming, 2, pp. 207-214. 1982.”
   - [2] https://www.geeksforgeeks.org/smallest-sum-contiguous-subarray/.
   
   
   
   Tivemos problemas em compreender a sintaxe utilizada no pseudo código.
   
*)


(*
  Module: PaperExample
  Date: 12/06/2021
  Description: Implementação do exemplo do artigo [1]
*)
module PaperExample
  use int.Int
  use ref.Ref
  use array.Array
  use array.ArraySum

  let example (v: array int) : int
    requires{length v >= 0}
    ensures{let n = length v in result = (sum v 0 n) }
    =
    let n = length v in
    let p = ref 0 in
    
    for i=0 to n-1 do
      invariant{0 <= i <= n}
      invariant{!p = (sum v 0 i)}
      p := !p + v[i]
    done;
    !p
end


(*
  Module: Exercise
  Date: 12/06/2021
  Description: Implementação do exemplo do artigo [1]
*)
module Exercise
  use int.Int
  use int.MinMax
  use ref.Ref
  use array.Array
  use array.ArraySum
  use array.ArrayPermut
  
  let ex2 (a: int) : (int, array int)
    ensures {let r, v = result in
    
    forall i j:int. 0 <= i <= j < 1 -> r <= (sum v i j)}
   =
   let v = make 2 1 in
   
    assert{0 = (sum v 0 0)};
    v[0], v
end



